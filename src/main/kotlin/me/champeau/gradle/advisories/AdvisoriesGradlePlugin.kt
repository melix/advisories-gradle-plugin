/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package me.champeau.gradle.advisories

import me.champeau.gradle.advisories.internal.FileBackedVulnerabilitiesService
import me.champeau.gradle.advisories.internal.GitHubVulnerabilitiesService
import me.champeau.gradle.advisories.internal.InMemoryCachingVulnerabilitiesService
import org.gradle.api.InvalidUserDataException
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.ResolvableDependencies
import org.gradle.api.artifacts.component.ModuleComponentIdentifier
import org.gradle.api.artifacts.result.ResolvedComponentResult
import java.nio.file.Path
import java.util.concurrent.TimeUnit
import java.util.stream.Collectors

/**
 * A simple 'hello world' plugin.
 */
class AdvisoriesGradlePlugin : Plugin<Project> {
    companion object {
        private const val ENV_TOKEN = "GH_ADVISORIES_TOKEN"
        private const val PROP_TOKEN = "me.champeau.advisories.gh.token"
    }

    override fun apply(project: Project) {
        val cacheDir = project.gradle.gradleUserHomeDir.toPath().resolve("vulnerabilities-cache")
        val service = project.createService(cacheDir)
        project.configurations.all {
            it.incoming.afterResolve { it.verifyDependencies(service) }
        }
    }

    private
    fun ResolvableDependencies.verifyDependencies(service: VulnerabilitiesService) {
        resolutionResult.allComponents.parallelStream()
                .filter { it.id is ModuleComponentIdentifier }
                .collect(Collectors.toConcurrentMap(
                        { k: ResolvedComponentResult -> k.moduleVersion!! },
                        { k ->
                            val moduleVersion = k.moduleVersion!!
                            service.vulnerabilitiesFor("${moduleVersion.group}:${moduleVersion.name}")
                                    .findVulnerabilitiesForVersion(moduleVersion.version)
                        }
                ))
                .entries
                .stream()
                .filter { it.value.isNotEmpty() }
                .sorted()
                .forEach {
                    println("Version ${it.key} is vulnerable to ${it.value}")
                }

    }

    private
    fun Project.createService(cacheDir: Path): InMemoryCachingVulnerabilitiesService {
        return InMemoryCachingVulnerabilitiesService(
                FileBackedVulnerabilitiesService(
                        24,
                        TimeUnit.HOURS,
                        cacheDir,
                        GitHubVulnerabilitiesService(accessToken())
                )
        )
    }

    private
    fun Project.accessToken(): String = findTokenProperty() ?: findTokenEnvVariable()

    private
    fun findTokenEnvVariable(): String {
        val token = System.getenv().get(ENV_TOKEN)
        if (token == null) {
            throw InvalidUserDataException("You must specify your GitHub token either using the $ENV_TOKEN environment variable or the $PROP_TOKEN system property")
        }
        return token
    }

    private
    fun Project.findTokenProperty() =
            findProperty(PROP_TOKEN) as String?
}
