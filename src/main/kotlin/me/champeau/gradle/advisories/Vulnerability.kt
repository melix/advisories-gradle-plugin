package me.champeau.gradle.advisories

import kotlinx.serialization.*

@Serializable
data class Vulnerability(
        val ids: List<String>,
        val severity: Severity,
        val firstPatchedVersion: String?,
        val lowerVersion: Version?,
        val higherVersion: Version?,
        val summary: String,
        val description: String) {

    @Serializer(forClass = Vulnerability::class)
    companion object : KSerializer<Vulnerability> {
        val versionParser = org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser()
        var versionComparator = org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.DefaultVersionComparator().asVersionComparator()

        fun versionOf(version: String) = versionParser.transform(version)

        override fun serialize(encoder: Encoder, obj: Vulnerability) = obj.run {
            encoder.encodeInt(ids.size)
            ids.forEach(encoder::encodeString)
            encoder.encodeByte(severity.ordinal.toByte())
            encoder.nullable(firstPatchedVersion, encoder::encodeString)
            encoder.nullable(lowerVersion) {
                encoder.encodeString(it.name)
                encoder.encodeBoolean(it.included)
            }
            encoder.nullable(higherVersion) {
                encoder.encodeString(it.name)
                encoder.encodeBoolean(it.included)
            }
            encoder.encodeString(summary)
            encoder.encodeString(description)
        }

        override fun deserialize(decoder: Decoder): Vulnerability {
            val sz = decoder.decodeInt()
            val ids = mutableListOf<String>()
            for (i in 0 until sz) {
                ids.add(decoder.decodeString())
            }
            val severity = Severity.values()[decoder.decodeByte().toInt()]
            val firstPatchedVersion = decoder.nullable(Decoder::decodeString)
            val lowerVersion = decoder.nullable {
                Version(decoder.decodeString(), decoder.decodeBoolean())
            }
            val upperVersion = decoder.nullable {
                Version(decoder.decodeString(), decoder.decodeBoolean())
            }
            val summary = decoder.decodeString()
            val desc = decoder.decodeString()
            return Vulnerability(ids, severity, firstPatchedVersion, lowerVersion, upperVersion, summary, desc)
        }

        inline fun <T> Encoder.nullable(obj: T?, action: (T) -> Unit) {
            encodeBoolean(obj == null)
            if (obj != null) {
                action(obj)
            }
        }

        inline fun <T> Decoder.nullable(action: (Decoder) -> T): T? {
            if (decodeBoolean()) {
                return null
            }
            return action(this)
        }
    }

    // DANGER ZONE: THIS USES INTERNAL APIS
    fun appliesTo(version: String): Boolean {
        val tested = versionOf(version)
        if (higherVersion != null) {
            if (higherVersion.included && higherVersion.name == version) {
                return true
            }
            val higher = versionOf(higherVersion.name)
            if (versionComparator.compare(tested, higher)<0) {
                if (lowerVersion == null) {
                    return true;
                }
                if (lowerVersion.included && lowerVersion.name == version) {
                    return true;
                }
                val lower = versionOf(lowerVersion.name)
                if (versionComparator.compare(tested, lower)>0) {
                    return true
                }
            }
        }
        return false;
    }
}
